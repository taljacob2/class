TODO:

add a MUST to MemberList constructor to add Constructor and Destructor functions.
cargo new --bin project_name


-------------------------------------------------------------
TODO:


Think of a way to implement Constructor / Destructor in an easier way than static interfaces.

Maybe add to memberList somehow.


-----------------------------------------------------------------
TODO:

do this for every memberList:

for safety if you have a pointer to the memberList and could possibly free more than once.

```

void *Legacy_AtomicFreerDestructor(Legacy_AtomicFreer *atomicFreer) {
    if (atomicFreer == NULL) { return NULL; }

    if (atomicFreer->memberList->destructorInvocationStatus == WAS_NOT_INVOKED) {
        atomicFreer->memberList->destructorInvocationStatus = WAS_INVOKED_ONCE;
        free(atomicFreer->data);

        free(atomicFreer->memberList);

        free(atomicFreer);
    }

    return NULL;
}

```


----------------------------------------------------------------


TODO:

if `build.sh` in `build.yml` is on error on GitHub then exit `build.yml`


---------------------------------------------------------------

TODO:

#define _OBJECT_FIELDS_ (bitfield that contains *Legacy_Object and *MemberList)


and include in every future memberList.

--------------------------------------------------------------


TODO:

if you make all methods in MemberList, then the `sizeof` every future memberList
will be the same (and will be `sizeof(ObjectContainer)`),

and then you could dynamically allocate ObjectContainer with a constant size,

so you could make a generic constructor that is:

```
ObjectContainer *Constructor("className"){

    // ...
    ObjectContainer *instance = calloc(1, sizeof(ObjectContainer));
    // ...

}
```


-----------------------------------------------

TODO:

At the end:


// typedef ObjectContainer AUTO;

typedef ObjectContainer VAR;


--------------------------------------------

TODO:

at the end:

make a script that extends the compiler:

when it runs, it scans through the code, and turns it into objects with the form
of the `ObjectDefines.r`

For example when a user creates a class like so:


--------------------------------------

TODO:

rename `MemberList` to `Legacy_MemberList`

rename `MemberList` to `MemberList`

rename `ObjectContainer` to `MemberList`

rename `Legacy_Object` to `Legacy_ObjectComponent`

rename `Legacy_ObjectContainer` to `Legacy_Object`

-----

Then, show the `MemberList` field pointer in `MemberList` (so it won't be anonymous
anymore) -----> so you need to edit in "ObjectDefines.r":

```
#define OBJECT_CONTAINER_FIELDS \
    ANONYMOUS_POINTER_AS_FIELD; \
    MemberList *memberList;
```

and rename `OBJECT_CONTAINER_FIELDS` to `OBJECT_FIELDS`



---------------------------------------

