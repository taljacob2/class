TODO:

add a MUST to Object constructor to add Constructor and Destructor functions.
cargo new --bin project_name


-------------------------------------------------------------
TODO:


Think of a way to implement Constructor / Destructor in an easier way than static interfaces.

Maybe add to memberList somehow.


-----------------------------------------------------------------
TODO:

do this for every legacyObjectComponent:

for safety if you have a pointer to the legacyObjectComponent and could possibly free more than once.

```

void *Legacy_AtomicFreerDestructor(Legacy_AtomicFreer *atomicFreer) {
    if (atomicFreer == NULL) { return NULL; }

    if (atomicFreer->legacyObjectComponent->destructorInvocationStatus == WAS_NOT_INVOKED) {
        atomicFreer->legacyObjectComponent->destructorInvocationStatus = WAS_INVOKED_ONCE;
        free(atomicFreer->data);

        free(atomicFreer->legacyObjectComponent);

        free(atomicFreer);
    }

    return NULL;
}

```


----------------------------------------------------------------


TODO:

if `build.sh` in `build.yml` is on error on GitHub then exit `build.yml`


---------------------------------------------------------------

TODO:

#define _OBJECT_FIELDS_ (bitfield that contains *Legacy_Object and *Object)


and include in every future legacyObjectComponent.

--------------------------------------------------------------


TODO:

if you make all methods in MemberList, then the `sizeof` every future legacyObjectComponent
will be the same (and will be `sizeof(ObjectContainer)`),

and then you could dynamically allocate ObjectContainer with a constant size,

so you could make a generic constructor that is:

```
ObjectContainer *Constructor("className"){

    // ...
    ObjectContainer *instance = calloc(1, sizeof(ObjectContainer));
    // ...

}
```


-----------------------------------------------

TODO:

At the end:


// typedef ObjectContainer AUTO;

typedef ObjectContainer VAR;


--------------------------------------------

TODO:

at the end:

make a script that extends the compiler:

when it runs, it scans through the code, and turns it into objects with the form
of the `ObjectDefines.r`

For example when a user creates a class like so:


--------------------------------------

TODO:

DONE: rename `MemberList` to `Legacy_MemberList`

DONE: rename `Object` to `MemberList`

DONE: rename `ObjectContainer` to `Object`

DONE: rename `Legacy_Object` to `Legacy_ObjectComponent`

DONE: rename `Legacy_ObjectContainer` to `Legacy_Object`
----
DONE: Then reformat-code of all project.
-----

Then, show the `MemberList` field pointer in `Object` (so it won't be anonymous
anymore) -----> so you need to edit in "ObjectDefines.r":

```
#define OBJECT_CONTAINER_FIELDS \
    ANONYMOUS_POINTER_AS_FIELD; \
    MemberList *memberList;
```

DONE: and rename `OBJECT_CONTAINER_FIELDS` to `OBJECT_FIELDS`



---------------------------------------

TODO:

Let "c89" / "-Wpedantic" users be supported by `oop.a`:

- change all line comments of (// ... ) to ( /* ... */ )
- compile the `oop.a` library with the most restricted `-Wpedantic ...` and `-std=c89`

------------------------------------

TODO:

when you release the library, you must include ALL the `.h` (and `.r`) files.

So when you release: you MUST "zip" the whole "src/oop" folder, so it would the
`.h` / `.r` files and `oop.a`.


------------------------------


TODO:

in README.md:
in `Dynamic Allocation` section:

tell the user that he can also destruct the object implicitly by himself if he
wants to destruct immediately.
Also, tell him that every object is "multiple free safe": so he could destruct
multiple times the same object and it won't crash.

